### 题目
选择排序
选择排序（Selection sort）是一种简单直观的排序算法。
它的工作原理如下。
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，
然后，再从剩余未排序元素中继续寻找最小（大）元素，
然后放到已排序序列的末尾。
以此类推，直到所有元素均排序完毕。

#### 思路
1. 循环每一个元素，将当前元素记录为最小元素值
2. 找出后面所有元素中，最大（或最小）的元素，交换初始值和找到的最大（最小值）
3. 输出完成循环交换之后的数组，即可验证校验结果

#### Code
```C
#include <stdio.h>

void swap(int *a, int *b)
{
	// printf("a, b: %d %d\n", a, b);  // 输出的是传入的实参值（即地址信息）
	// printf("*a, *b: %d %d\n", *a, *b);  // *a *b 标识取出指定地址中的内容
	// 传入两个地址，交换两个地址空间中存放的值
	int temp = *a;  // temp中存储地址a中存放的值		此处的*a 就像当于，平时定义的常量int a;
	*a = *b;		// 取出地址b中存储的值，并放入到a值中
	*b = temp;		// 将临时变量temp中的值复制给b。
}

void selectSort(int arr[], int len)
{
	int i, j;
	// 取第一个值，分别和后面的每一个值进行对比，找到最小值，替换两个地址的值 - 循环
	for (i = 0; i < len; i++){
		int min = i;
		for (j = i+1;j<len;j++){
			// 循环一轮，找到值最小的下标，替换为min值，然后交换min和i对应的数组值
			if (arr[j] < arr[min]){
				min = j;
			}
		}
		swap(&arr[min], &arr[i]);
	}
	// printf("***********************************\n");
	for(int k = 0;k < len;k++){
		printf("%d ", arr[k]);
	}
}

int main()
{
	int arr[10] = { 34, 23, 345, 67, 93, 1984, 32, 504, 654, 604 };
	int len = sizeof(arr)/sizeof(arr[0]);
	selectSort(arr, len);
}
```

#### PS
记录选择排序的梳理过程，依次查找数组中最大(最小)从前向后排放，循环完成，即完成了数组的排序工作！
