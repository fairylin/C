### 题目
清朝时期，国王选妃。国王看中了段飞的女朋友，在段飞的苦苦哀求下，国王终于给了他一次夺回女朋友的机会。国王说我给你n对数字（每对有数字a，b两个），你需要求出每两个数字的第K个公约数。如果全部对的话，你就可以带走你的女朋友了，如果有一个错的话她就是国王的王妃了。
第k个公约数：
比如8和16，公约数1，2，4，8.（8=1x2x2x2，8=2x4x1，这样2可能重复，我们把它记作一个数。所以8和是16的公约数是1 2 4 8 第三个公约数是4

解答要求
时间限制：1000ms, 内存限制：64MB
输入
给你三个数字a，b，k(a,b,k在int范围内)。

输出
输出一行，给个a和b的第k个公约数。如果这两个数字没有第k个公约数，则输出0.

样例
输入样例 1 复制

8 16 3
输出样例 1

4

#### 解决方案
1. 找到传入两个数的最大公约数（欧几里得方法求解），作为循环判断的条件终点（降低时间复杂度）
2. 注意判断第k个值和数组下标的对应关系；数组下标从0开始， 所以第k个值对应数组下标为k-1


```C
#include <stdio.h>
#define MAX 1000

int maxGCD(int m, int n)
{
	// 求最大公约数
	// 欧几里得方法计算两个数的最大公约数
    if(n == 0)
        return m;
    return maxGCD(n, m % n);
}

int main()
{
	int a, b, k;
	int al[MAX] = {};
	scanf("%d %d %d", &a, &b, &k);
	int num = maxGCD(a, b);
	int j = 0;
	for(int i = 1; i <= num; i++){			// 优化：从最开始直接判断条件至a，b中的较小值调整到最大公约数
		if (a % i == 0 && b % i == 0){		// 当i是a和b的的公约数时，才放到数组中
			al[j] = i;						// 数组下标加1，指向下一个位置
			j++;
		}
	}
	if (k <= j){				// k 从1 开始计数，j从0开始计数，此处的j比数组中正确的最大下标多了1
		printf("%d", al[k-1]);	// k 和 j的正确对应关系为：第k个值在数组中对应的下标为k-1，
	} else {					// k-1=j即可找到对应的值（此处j的值已经完成了自加操作）
		printf("0");
	}
	return 0;
}
```

PS：第K个公约数介绍就到这里！欢迎探讨！
