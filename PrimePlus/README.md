### 题目
编写一个程序，读取整数n，并打印小于等于n的质数的数量。
素数是一个自然数，它正好有两个不同的自然数除数：1和它本身。
例如，前4个质数为：2, 3, 5, 7。

PS: 部分版本编译器中使用的布尔型数组定义需要使用bool类型

#### 思路

1. 定义数组统计实现各个下标对应数值是否是素数的判断；
2. 根据埃拉托斯特尼筛法 进行筛选

> 埃拉托斯特尼筛法是一个快速获取小于数X的所有素数集合的算法。
> 首先我们要明确，假设一个合数x能表示为两个数的乘积，他必定有一个小于等于sqrt(x)的因子，这可以用归谬证明法证明。如果两个因子都大于sqrt(x)，那么乘积大于x,这和假设矛盾。
> 所以，判断一个数x是否是合数，只要依次除以2至sqrt(x)间的素数，判断是否整除即可。

> 埃拉托斯特尼筛法基于以下原理，给定一个素数n>1,kn是一个合数(k>1)，例如n=3,那么6,9,12,15…都是合数。

> 以100为例，我们先创建一个100个数字的数组。
> 先使用最小的素数2，将所有2的倍数(除2本身)标记为合数。
> 接下来2+1的数是3，此时检查3是不是素数，检查标记，发现没有被标记为合数(因为不是2的倍数)，所以再将所有3的倍数标记为合数。
> 下一个数是4，发现他已经被标记为合数，所以他可以表示小于4的素数的乘积2x2，所以4的倍数必定含有因子2，所以所有4的倍数已经全部被标记过，直接跳过4。
> 下一个数是5，没有被标记为合数，把所有小于100的5的倍数标记为合数
> ………这样一直计算到sqrt(100)，即10。
> 那么为什么不标记大于10的数例如11呢？因为所有的倍数已经被标记过了，例如22，33，44，55…分别有因子2，3，2，5，大于10的倍数，例如11x11已经超过max了，参见最上面的推论
> 注意这里有一个优化点，很多书籍上或者教程上都没有说出来，只要标记大于本身的倍数就行了，例如5，只要标记5x5,5x6,5x7…为合数，因为5x2,5x3,5x4…已经被之前出现的数的倍数标记过了 
3. 除了2以外，其余的数据判断，如果是偶数一定是2的倍数，一定是合数，所以直接从3开始判断，依次加2进行下一个数的判断；
4. 依次判断每个奇数是否是素数，如果是素数则count值+1，最后输出count值，即输入数值num以内所有的素数值个数；

```C
#include <stdio.h>

int num;  // 定义输入需要判断的数值num
_Bool priCheck[50000010] = {};  // 定义进行埃拉托斯特尼筛选的素数存放数组

int isPrime(int x)
{
	if (priCheck[x/2] != 0){
		return 0;   // x/2下标不等于0，则为1，说明该位置对应的下标值是合数
	}
	for (int i=3;i <= num / x;i+=2){
		priCheck[i * x / 2] = 1;  // 设置下标值对应的内容是合数，值设置为1
	}
	return 1;  // 如果x/2为1， 则直接返回x为合数
}

int main()
{
	int count = 0;
	scanf("%d", &num);
	if(num>=2){
		count++;
	}
	for (int i = 3;i<=num;i+=2){
		if(isPrime(i)){
			count++;
		}
	}
 	printf("%d\n", count);
}
```

PS：使用埃筛定理进行素数判断的方式介绍到这里！欢迎探讨！
